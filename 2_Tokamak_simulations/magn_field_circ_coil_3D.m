% Function to evaluate the magnetic field B at a point generated by a
% circular coil located at c_coil, with a radius R_coil. The coil will be
% approximated by N_segments straight segments. The coil is located at plane
% Z=0 with a global coordinate system typical in tokamaks:
% X (radial), Y (toroidal) Z (vertical)

% r_evaluate_B=[0 0 2]';
% %Center of the coil
% % c_coil=[2 2 2];
% c_coil=[1.65 0 0];
% %Radius of the coil
% R_coil=R_toroidal_coil;
% %Number of segments of the coil
% N_segments=N_segments_toroidal_coil;
% % 3 rotations to orient coil
% rotations=[pi/2 0 0];


function [output]=magn_field_circ_coil_3D(I,r,c_coil,R_coil,N_segments,rotations)
global mu0  


%% Generate coordinates of the points of each segment of coil
%First in local coordinates (center of the coil with z direcc normal)
ang_coil=linspace(0,2*pi,N_segments+1); %The first and the las coincide
coords_local_coil=[R_coil*cos(ang_coil)' R_coil*sin(ang_coil)' zeros(1,length(ang_coil))'];

% Coil Position and orientation by matrix transformations
% Rotation matrix around X
rx=[1 0 0; 0 cos(rotations(1)) -sin(rotations(1)); 0 sin(rotations(1)) cos(rotations(1))];
% Rotation matrix around Y
ry = [cos(rotations(2)) 0 sin(rotations(2)); 0 1 0; -sin(rotations(2)) 0 cos(rotations(2))];
% Rotation matrix around Z
rz = [cos(rotations(3)) -sin(rotations(3)) 0; sin(rotations(3)) cos(rotations(3)) 0; 0 0 1];
% Then perform rotation about x
rotated_x = mtimes(rx,[coords_local_coil(:,1)';coords_local_coil(:,2)';coords_local_coil(:,3)'])';
% Then perform rotation about y
rotated_xy = mtimes( ry, rotated_x')';
% Then perform rotation about z
rotated_xyz = mtimes( rz, rotated_xy')';

% Traslation to coil center
coords_coil_glob=rotated_xyz+[c_coil(1).*ones(1,length(rotated_xyz))' ...
    c_coil(2).*ones(1,length(rotated_xyz))' c_coil(3).*ones(1,length(rotated_xyz))'];
% Evaluate the magnetic field at the point by biot-savart. For each segment
B=[0 0 0]';
Bi=[0 0 0]';
lista_Bi=[];
lista_ding=[]; % To determine if the point is too close to the segment
epsilon=2e-2;
for m = 1:length(coords_coil_glob)-1
    ri1 = coords_coil_glob(m,:)';
    ri2 = coords_coil_glob(m+1,:)';
    ding=0;
%     if  norm(r-ri1)<epsilon && norm(r-ri2)<epsilon;
%         ding=1;
%         Bi=[0 0 0]';
%         B=B+Bi;
%     else
        fact_mu=mu0*I/(4*pi);
%         tic
        d1=r-ri1;
        d2=r-ri2;
        mod_d1=sqrt(d1(1)*d1(1)+d1(2)*d1(2)+d1(3)*d1(3));
        mod_d2=sqrt(d2(1)*d2(1)+d2(2)*d2(2)+d2(3)*d2(3));
        d1crossd2=[d1(2)*d2(3)-d1(3)*d2(2) d1(3)*d2(1)-d1(1)*d2(3) d1(1)*d2(2)-d1(2)*d2(1)]';
        d1plusd2=mod_d1+mod_d2;
        d1timesd2=mod_d1*mod_d2;
        d1dotd2=d1(1)*d2(1)+d1(2)*d2(2)+d1(3)*d2(3);
        Bi=fact_mu*d1crossd2*d1plusd2...
            ./(d1timesd2+d1dotd2)/d1timesd2;
        B = B + Bi;
%         t_ju=toc
        %Erika´s expression
%         tic
%         dx1=r(1)-ri1(1);
%         dx2=r(1)-ri2(1);
%         dy1=r(2)-ri1(2);
%         dy2=r(2)-ri2(2);
%         dz1=r(3)-ri1(3);
%         dz2=r(3)-ri2(3);
%         rw1  =sqrt(dx1*dx1+dy1*dy1+dz1*dz1);
%         rw2  =sqrt(dx2*dx2+dy2*dy2+dz2*dz2);
%         r12  =rw1*rw2;
%         som  =rw1+rw2;
%         sk   =1/(r12*(r12+dx1*dx2+dy1*dy2+dz1*dz2));
%         fk   =som*sk;
%         ak   =fact_mu*fk;
%         rotx =dy1*dz2-dz1*dy2;
%         roty =dz1*dx2-dx1*dz2;
%         rotz =dx1*dy2-dy1*dx2;
%         Bi=[ak*rotx ak*roty ak*rotz]';
%         %         bx   =bx + ak*rotx;
%         %         by   =by + ak*roty;
%         %         bz   =bz + ak*rotz;
%         B=B+Bi;
%         t_er=toc;
%     end
%     lista_Bi_er=[lista_Bi_er Bi_er];
%     lista_Bi_ja=[lista_Bi_ja Bi_ja];
    lista_Bi=[lista_Bi Bi];
    lista_ding=[lista_ding ding];
end
output.B=B;
output.mod_B=norm(B);
output.coords_coil=coords_coil_glob;
output.lista_Bi=lista_Bi;
output.lista_ding=lista_ding;

